Slava Muravjev, [8/8/2022 11:14 PM]
[In reply to First name Last name]
я не заканчиваю обратную связь, пока мы не придем к пониманию

Slava Muravjev, [8/8/2022 11:14 PM]
ну смотрите

Slava Muravjev, [8/8/2022 11:14 PM]
у вас есть два вектора индексов

Slava Muravjev, [8/8/2022 11:14 PM]
1) индексы домов

Slava Muravjev, [8/8/2022 11:14 PM]
2) индексы магазинов

Slava Muravjev, [8/8/2022 11:14 PM]
ваша цель минимизировать значение выражения |house[i] - shop[j]|

Slava Muravjev, [8/8/2022 11:15 PM]
очев, что данный модуль раскрывается двумя способами (как раз мы говорим о ближайшем слева / справа)

Slava Muravjev, [8/8/2022 11:15 PM]
ну рассмотрим ближайший справа

Slava Muravjev, [8/8/2022 11:15 PM]
наша цель - в массиве индексов shop найти первый >= house[i]

Slava Muravjev, [8/8/2022 11:15 PM]
это прям строго двоичный поиск во плоти

Slava Muravjev, [8/8/2022 11:15 PM]
кстати, ближайший слева будет просто соседом найденного ближайшего справа

Slava Muravjev, [8/8/2022 11:16 PM]
ИЛИ вы можете засунуть все индексы магазинов в дерево поиска, после чего вызывать аналогичный метод спуска по дереву (upper_bound в С++ / higher в Java) у структуры дерева



дима, [8/8/2022 11:02 PM]
2 0 1 1 0 1 0 2 1 2

дима, [8/8/2022 11:03 PM]
Вектор будет 0 7 9

дима, [8/8/2022 11:03 PM]
Левая граница 0, правая 1
Значения 0, 7 соответственно

дима, [8/8/2022 11:03 PM]
Идёшь по входному массиву

дима, [8/8/2022 11:03 PM]
Встретил 1

дима, [8/8/2022 11:04 PM]
ans = min({ans, index - v[l], index - v[r]})

дима, [8/8/2022 11:05 PM]
Если v[r] < index то смещаем вправо границы пока v[r] не станет больше >

дима, [8/8/2022 11:05 PM]
Ну и все

дима, [8/8/2022 11:06 PM]
Общий алгоритм такой

дима, [8/8/2022 11:06 PM]
Обработать только если меньше двух магазинов случай

дима, [8/8/2022 11:07 PM]
Ну и там когда вправо границы двигаешь если так и не дошёл до того шоб правая границы была больше индекса, то остаётся у тебя только левая граница
